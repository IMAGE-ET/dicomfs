#!/usr/bin/env python

#
#    This program can be distributed under the terms of the GNU LGPL.
#

import os, stat, errno, commands, sys, re

try:
    import _find_fuse_parts
except ImportError:
    pass
import fuse
from fuse import Fuse


if not hasattr(fuse, '__version__'):
    raise RuntimeError, \
        "your fuse-py doesn't know of fuse.__version__, probably it's too old."

fuse.fuse_python_api = (0, 2)


def listPatients(self):
	return commands.getoutput("/usr/bin/findscu -aec "+self.aec+" -k 0008,0052=STUDY -k 0020,000d  "+self.serveraddress+" "+self.serverport+" |grep PatientsName | sed 's/.*\[\(.*\)\].*/\\1/'").replace(";","_").replace("/","_").splitlines()

def listStudies(self):
	return commands.getoutput("/usr/bin/findscu -aec "+self.aec+" -k 0008,0052=STUDY -k 0020,000d "+self.serveraddress+" "+self.serverport+" |grep '^(0020,000d)' | sed 's/.*\[\(.*\)\].*/\\1/'" ).replace(";","_").replace("/","_").splitlines()

def uploadFile(self,path):
	commands.getoutput("/usr/bin/storescu -R -aec "+self.aec+" "+self.serveraddress+" "+self.serverport+" -aet "+self.aet +' "'+path +'"')
	commands.getoutput("rm -R " +' "'+path +'"')

def downloadStudy(self,studyID):
	lastdir=os.getcwd()
	os.makedirs(self.cachedir+"/Studies/"+studyID)
	os.chdir(self.cachedir+"/Studies/"+studyID)
	commands.getoutput("/usr/bin/movescu --prefer-jpeg8 --bit-preserving " + self.serveraddress+" "+self.serverport+" -aec "+self.aec+ " -S +P "+self.localport+" --aetitle "+self.aet+ " -aem "+self.aet+" --key 0020,000D="+studyID+" --key 0008,0052=STUDY")
	result=commands.getoutput("ls "+self.cachedir+"/Studies/"+studyID+"/")
	os.chdir(lastdir)
	return result.replace(";","_").replace("/","_").splitlines()

class DicomObject():
	def __init__(self):
		self.studyUID=""
		self.patientName=""
		self.studyName=""

def flag2mode(flags):
	md = {os.O_RDONLY: 'r', os.O_WRONLY: 'w', os.O_RDWR: 'w+'}
	m = md[flags & (os.O_RDONLY | os.O_WRONLY | os.O_RDWR)]
	if flags | os.O_APPEND:
		m = m.replace('w', 'a', 1)
	return m

class MyStat(fuse.Stat):
    def __init__(self):
        self.st_mode = 0
        self.st_ino = 0
        self.st_dev = 0
        self.st_nlink = 0
        self.st_uid = 0
        self.st_gid = 0
        self.st_size = 0
        self.st_atime = 0
        self.st_mtime = 0
        self.st_ctime = 0

def getInformationModel(path):
	if re.match("/Patient Root/.*",path):
		return "PR"
	if re.match("/Patient Study/.*",path):
		return "PS"
	if re.match("/Study Root/.*",path):
		return "PS"
	if re.match("/Worklist/.*",path):
		return "W"
	return None

def getLevels(path):
	return path.split("/")


class XmpFile(object):

        def __init__(self, path, flags, *mode):
            self.file = os.fdopen(os.open(self.cachedir + path, flags, *mode),
                                  flag2mode(flags))
            self.fd = self.file.fileno()
            self.upload = False

        def read(self, length, offset):
            self.file.seek(offset)
            return self.file.read(length)

        def write(self, buf, offset):
            self.file.seek(offset)
            self.file.write(buf)

            return len(buf)

        def release(self, flags):
            self.file.close()
            if self.upload:
        	uploadFile(self,self.cachedir+path)
            self.upload = False

        def _fflush(self):
            if 'w' in self.file.mode or 'a' in self.file.mode:
                self.file.flush()

        def fsync(self, isfsyncfile):
            self._fflush()
            if isfsyncfile and hasattr(os, 'fdatasync'):
                os.fdatasync(self.fd)
            else:
                os.fsync(self.fd)

        def flush(self):
            self._fflush()
            # cf. xmp_flush() in fusexmp_fh.c
            os.close(os.dup(self.fd))

        def fgetattr(self):
            return os.fstat(self.fd)

        def ftruncate(self, len):
            self.file.truncate(len)

        def lock(self, cmd, owner, **kw):
            # The code here is much rather just a demonstration of the locking
            # API than something which actually was seen to be useful.

            # Advisory file locking is pretty messy in Unix, and the Python
            # interface to this doesn't make it better.
            # We can't do fcntl(2)/F_GETLK from Python in a platfrom independent
            # way. The following implementation *might* work under Linux. 
            #
            # if cmd == fcntl.F_GETLK:
            #     import struct
            # 
            #     lockdata = struct.pack('hhQQi', kw['l_type'], os.SEEK_SET,
            #                            kw['l_start'], kw['l_len'], kw['l_pid'])
            #     ld2 = fcntl.fcntl(self.fd, fcntl.F_GETLK, lockdata)
            #     flockfields = ('l_type', 'l_whence', 'l_start', 'l_len', 'l_pid')
            #     uld2 = struct.unpack('hhQQi', ld2)
            #     res = {}
            #     for i in xrange(len(uld2)):
            #          res[flockfields[i]] = uld2[i]
            #  
            #     return fuse.Flock(**res)

            # Convert fcntl-ish lock parameters to Python's weird
            # lockf(3)/flock(2) medley locking API...
            op = { fcntl.F_UNLCK : fcntl.LOCK_UN,
                   fcntl.F_RDLCK : fcntl.LOCK_SH,
                   fcntl.F_WRLCK : fcntl.LOCK_EX }[kw['l_type']]
            if cmd == fcntl.F_GETLK:
                return -EOPNOTSUPP
            elif cmd == fcntl.F_SETLK:
                if op != fcntl.LOCK_UN:
                    op |= fcntl.LOCK_NB
            elif cmd == fcntl.F_SETLKW:
                pass
            else:
                return -EINVAL

            fcntl.lockf(self.fd, op, kw['l_start'], kw['l_len'])



class DicomFS(Fuse):

	def __init__(self, *args, **kw):
		Fuse.__init__(self, *args, **kw)
# do stuff to set up your filesystem here, if you want
#import thread
#thread.start_new_thread(self.mythread, ())
		self.root = '/'
		self.serveraddress="127.0.0.1"
		self.serverport="104"
		self.aec="ANY-SCP"
		self.aet="MOVESCU"
		self.localport="10004"
		self.cachedir="/tmp/dicomfs"
		self.refresh='9999999999'

	def clearCaches(self):
		self.attributeCache=dict()
		self.directoryCache=dict()
		commands.getoutput("rm -R "+self.cachedir+"/*")

	def empty(self):
		pass

	def runOnce(self):
		self.clearCaches()
		self.runOnce=self.empty

	def getattr(self, path):
		self.runOnce()
		if path in self.attributeCache:
			return self.attributeCache[path]
		st = MyStat()
		if len(getLevels(path)) <=3:
			st.st_mode = stat.S_IFDIR | 0755
			st.st_nlink = 2
		else:
			st=os.lstat(self.cachedir + path)
		self.attributeCache[path]=st
		return self.attributeCache[path]

	def readdir(self, path, offset):
		print(self.serveraddress,self.serverport,self.localport,self.aec,self.aet)
		if path=="/clearcaches":
			self.clearCaches()
		if path in self.directoryCache:
			for r in self.directoryCache[path]:
				yield fuse.Direntry(r)
			return

		tmp=list()
		tmp.append('.')
		tmp.append('..')

		if path == '/':
			for r in  'Patient-Study-Modality-Series-Instance', 'Studies', 'clearcaches':
				tmp.append(r)
		if path.strip() == '/Patient-Study-Modality-Series-Instance':
			print (listPatients(self))
			tmp.extend(listPatients(self))
		if path.strip() == '/Studies':
			tmp.extend(listStudies(self))

		if len(getLevels(path))>2 and getLevels(path)[1] == 'Studies':
#			commands.getoutput("/home/dvolgyes/workspace/dicomfs/downloadStudy.pl "+)
			downloadStudy(self,getLevels(path)[2])
			tmp.extend(commands.getoutput("ls "+self.cachedir+path).splitlines())

		for name in tmp:
			yield fuse.Direntry(name)
		self.directoryCache[path]=tmp

#	def open(self, path, flags):
#		if path != hello_path:
#			return -errno.ENOENT
#		accmode = os.O_RDONLY | os.O_WRONLY | os.O_RDWR
#		if (flags & accmode) != os.O_RDONLY:
#			return -errno.EACCES

#	def read(self, path, size, offset):
#		if offset < slen:
#			if offset + size > slen:
#				size = slen - offset
#				buf = hello_str[offset:offset+size]
#		else:
#			buf = ''
#		return buf


	def main(self, *a, **kw):
		self.file_class = XmpFile
		return Fuse.main(self, *a, **kw)


def main():
    usage="""
DicomFS 

""" + Fuse.fusage
    server = DicomFS(version="%prog " + fuse.__version__,
                     usage=usage,
                     dash_s_do='setsingle')

    server.multithreaded = False

    server.parser.add_option(mountopt="serveraddress", metavar="IP", default=server.serveraddress, help="remote DICOM server IP address [default: %default]")
    server.parser.add_option(mountopt="serverport", metavar="PORT", default=server.serverport, help="remote DICOM server port [default: %default]")
    server.parser.add_option(mountopt="aec", metavar="AETITLE", default=server.aec, help="called AE title of peer [default: %default]")
    server.parser.add_option(mountopt="aet", metavar="AETITLE", default=server.aet, help="calling AE title [default: %default]")
    server.parser.add_option(mountopt="localport", metavar="PORT", default=server.localport, help="local port [default: %default]")
    server.parser.add_option(mountopt="cachedir", metavar="PATH", default=server.cachedir, help="directory for caching [default: %default]")
    server.parser.add_option(mountopt="refresh", metavar="SEC", default=server.refresh, help="network refresh time (cache clear time) [default: %default]")

    server.parse(values=server, errex=1)
    server.main()

if __name__ == '__main__':
    main()
